<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hotline-ish Retro — Single File</title>
<style>
  :root{
    --bg:#0b0b10; --panel:#0f1720; --accent:#ff2d95; --accent2:#00e6ff; --muted:#c9c9c9;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,Arial,Helvetica,sans-serif;display:flex;align-items:center;justify-content:center;overflow:hidden;color:var(--muted)}
  #container{position:relative;width:960px;height:640px;box-shadow:0 12px 40px rgba(0,0,0,0.8);border-radius:6px;overflow:hidden;background:linear-gradient(180deg,#0b0b10,#06060a);}
  canvas{display:block;background:transparent;margin:0}
  /* HUD */
  #hud{position:absolute;left:12px;top:10px;z-index:8;font-size:14px}
  .hud-line{margin-bottom:6px}
  .bar-wrap{width:200px;height:10px;background:rgba(255,255,255,0.06);border-radius:6px;overflow:hidden;display:inline-block;vertical-align:middle;margin-left:8px}
  .bar{height:100%;background:linear-gradient(90deg,var(--accent),#ff7ab8);width:100%}
  /* centre menu */
  #menu{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;background:linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.65));backdrop-filter:blur(3px)}
  .menu-box{width:360px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);padding:18px;border-radius:10px;text-align:center}
  h1{color:var(--accent);margin:6px 0 4px;font-size:22px}
  p.desc{color:rgba(255,255,255,0.7);font-size:13px;margin:0 0 12px}
  .weapons{display:flex;gap:8px;justify-content:center;margin-bottom:12px}
  .weapon-btn{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);cursor:pointer;position:relative}
  .weapon-btn.locked{opacity:0.45;cursor:default}
  .weapon-btn.selected{outline:2px solid rgba(255,255,255,0.08)}
  .weapon-lock{position:absolute;right:8px;top:8px;font-size:12px;color:rgba(255,255,255,0.6)}
  .level-select{display:flex;gap:8px;margin-bottom:12px}
  .level-btn{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);cursor:pointer}
  .start-row{display:flex;gap:8px;justify-content:center;align-items:center}
  button.start{padding:10px 16px;border-radius:8px;border:none;background:var(--accent);color:#111;font-weight:700;cursor:pointer}
  button.start.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .meta{font-size:12px;color:rgba(255,255,255,0.6);margin-top:8px}
  /* top-right score */
  #scoreBox{position:absolute;right:12px;top:10px;z-index:8;text-align:right}
  /* small mobile adjustments */
  @media (max-width:1000px){ #container{width:800px;height:560px} canvas{width:800px;height:560px} }
</style>
</head>
<body>
<div id="container">
  <canvas id="game" width="960" height="640"></canvas>

  <div id="hud">
    <div class="hud-line">Liv: <span id="hpText">100</span>
      <span class="bar-wrap"><span class="bar" id="hpBar" style="width:100%"></span></span>
    </div>
    <div class="hud-line">Våben: <span id="weaponName">Pistol</span></div>
  </div>

  <div id="scoreBox"><div>Score: <span id="scoreText">0</span></div></div>

  <div id="menu" aria-hidden="false">
    <div class="menu-box">
      <h1>Hotline-ish (Retro)</h1>
      <p class="desc">Klik våben for at vælge. Skyd med musen. WASD bevæg. Level 1 unlocker shotgun når du gennemfører.</p>

      <div class="weapons" id="weapons">
        <div class="weapon-btn selected" data-id="pistol" id="w-pistol">
          <div style="font-weight:700">Pistol</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">Hurtig, enkelt skud</div>
        </div>
        <div class="weapon-btn locked" data-id="shotgun" id="w-shotgun">
          <div style="font-weight:700">Shotgun</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">Langsom, spread (låst)</div>
          <div class="weapon-lock">Locked</div>
        </div>
      </div>

      <div class="level-select">
        <div class="level-btn" data-level="1" id="lv1">Level 1 (clear)</div>
        <div class="level-btn" data-level="inf" id="lvinf">Level Infinite</div>
      </div>

      <div class="start-row">
        <button class="start" id="startBtn">Start spil</button>
        <button class="start secondary" id="credits">Instruktioner</button>
      </div>

      <div class="meta">R = genstart mid-game • Space = melee (kort rækkevidde)</div>
    </div>
  </div>
</div>

<script>
(function(){
  // DOM
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const menu = document.getElementById('menu');
  const startBtn = document.getElementById('startBtn');
  const wPistol = document.getElementById('w-pistol');
  const wShotgun = document.getElementById('w-shotgun');
  const hpText = document.getElementById('hpText');
  const hpBar = document.getElementById('hpBar');
  const weaponName = document.getElementById('weaponName');
  const scoreText = document.getElementById('scoreText');
  const lv1Btn = document.getElementById('lv1');
  const lvinfBtn = document.getElementById('lvinf');

  // game state
  let W = canvas.width, H = canvas.height;
  let keys = {}, mouse = {x:W/2,y:H/2,down:false};
  let player, bullets, enemies, walls, score=0, running=false, levelConfig=null, currentLevel=null;
  let selectedWeapon = 'pistol';
  let shotgunUnlocked = false;
  let levelChoice = '1'; // '1' or 'inf'

  // levels
  const LEVELS = {
    '1': {name:'Level 1', type:'finite', initial:6, maxTotalSpawns:18, spawnRate:1200, walls:makeWallsLevel1()},
    'inf':{name:'Infinite', type:'infinite', initial:4, spawnRate:900, walls:makeWallsLevel2()}
  };

  // weapons
  const WEAPONS = {
    pistol:{name:'Pistol', fireRate:140, bulletSpeed:9, damage:34, pellets:1},
    shotgun:{name:'Shotgun', fireRate:600, bulletSpeed:8, damage:22, pellets:7, spread:0.6}
  };

  // input
  window.addEventListener('keydown', e=>{
    keys[e.key.toLowerCase()] = true;
    if(e.key === 'r'){ restartLevel(); }
    if(e.code === 'Space'){ playerMelee(); }
  });
  window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);
  canvas.addEventListener('mousemove', e=>{
    const r = canvas.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
  });
  canvas.addEventListener('mousedown', e=> { mouse.down = true; });
  window.addEventListener('mouseup', e=> { mouse.down = false; });

  // menu interactions
  wPistol.addEventListener('click', ()=> { selectWeapon('pistol'); });
  wShotgun.addEventListener('click', ()=> { if(shotgunUnlocked){ selectWeapon('shotgun'); } });
  lv1Btn.addEventListener('click', ()=> { levelChoice='1'; highlightLevel(); });
  lvinfBtn.addEventListener('click', ()=> { levelChoice='inf'; highlightLevel(); });

  startBtn.addEventListener('click', ()=>{
    // use currently selected weapon (if shotgun locked, force pistol)
    if(selectedWeapon === 'shotgun' && !shotgunUnlocked) selectedWeapon = 'pistol';
    weaponName.textContent = WEAPONS[selectedWeapon].name;
    startLevel(levelChoice);
  });

  // helper: highlight level and weapon UI
  function highlightLevel(){
    if(levelChoice === '1'){ lv1Btn.style.outline = '2px solid rgba(255,255,255,0.06)'; lvinfBtn.style.outline = ''; }
    else { lvinfBtn.style.outline = '2px solid rgba(255,255,255,0.06)'; lv1Btn.style.outline = ''; }
  }
  function selectWeapon(id){
    selectedWeapon = id;
    // UI
    [wPistol,wShotgun].forEach(el=>el.classList.remove('selected'));
    if(id==='pistol') wPistol.classList.add('selected'); else wShotgun.classList.add('selected');
    weaponName.textContent = WEAPONS[selectedWeapon].name;
  }

  // make walls (rooms) - returns array of rects {x,y,w,h}
  function makeWallsLevel1(){
    // rooms with door gaps (we'll create rectangles for walls, leaving door gaps)
    return [
      // outer border (thin)
      {x:0,y:0,w:960,h:12},
      {x:0,y:628,w:960,h:12},
      {x:0,y:0,w:12,h:640},
      {x:948,y:0,w:12,h:640},
      // an inner building with a door (two rects left and right)
      {x:120,y:80,w:160,h:200}, // building 1 body
      {x:320,y:80,w:12,h:200}, // corridor wall
      {x:520,y:180,w:200,h:12}, // horizontal block
      {x:200,y:360,w:420,h:20},
      {x:760,y:220,w:12,h:200},
      {x:40,y:520,w:150,h:12}
    ];
  }
  function makeWallsLevel2(){
    return [
      {x:0,y:0,w:960,h:12},{x:0,y:628,w:960,h:12},{x:0,y:0,w:12,h:640},{x:948,y:0,w:12,h:640},
      {x:100,y:120,w:220,h:12},{x:100,y:120,w:12,h:120},{x:320,y:120,w:12,h:120},
      {x:420,y:220,w:220,h:12},{x:620,y:220,w:12,h:120},
      {x:260,y:400,w:360,h:12},{x:260,y:300,w:12,h:120}
    ];
  }

  // spawn logic
  function startLevel(levelId){
    currentLevel = LEVELS[levelId];
    levelConfig = { ...currentLevel };
    // reset
    bullets = []; enemies = []; score = 0;
    spawnCount = 0; totalSpawned = 0; lastSpawnTime = 0;
    player = { x:480, y:320, r:12, speed:2.6, hp:100, facing:0, meleeCooldown:0, lastShot:0 };
    walls = JSON.parse(JSON.stringify(levelConfig.walls || []));
    running = true;
    menu.style.display = 'none';
    hpText.textContent = player.hp;
    hpBar.style.width = '100%';
    weaponName.textContent = WEAPONS[selectedWeapon].name;
    scoreText.textContent = score;
    // initial spawns
    for(let i=0;i<(levelConfig.initial||4);i++) spawnEnemy();
  }

  function restartLevel(){
    if(!running) return;
    startLevel(levelChoice);
  }

  // enemy spawn helpers
  let spawnCount = 0, totalSpawned = 0, lastSpawnTime = 0;
  function spawnEnemy(){
    // spawn at random edge or in certain zones
    const edge = Math.floor(Math.random()*4);
    let x = 0, y = 0;
    if(edge===0){ x = 20; y = 40 + Math.random()*(H-80); }
    if(edge===1){ x = W - 20; y = 40 + Math.random()*(H-80); }
    if(edge===2){ x = 40 + Math.random()*(W-80); y = 20; }
    if(edge===3){ x = 40 + Math.random()*(W-80); y = H - 20; }
    enemies.push({ x, y, r:12, hp:70 + Math.floor(Math.random()*30), color:WEAPONS.pistol ? '#00e6ff' : '#00e6ff', attackCooldown:0 });
    spawnCount++; totalSpawned++;
  }

  // drawing helpers
  function clear(){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#081019'); g.addColorStop(1,'#05060a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function drawWalls(){
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    for(const w of walls){
      ctx.fillRect(w.x, w.y, w.w, w.h);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.strokeRect(w.x, w.y, w.w, w.h);
    }
  }

  function drawPlayer(){
    // body
    ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,45,149,0.98)'; ctx.fill();
    // facing arrow (triangle)
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    player.facing = ang;
    const ax = player.x + Math.cos(ang)*(player.r+10);
    const ay = player.y + Math.sin(ang)*(player.r+10);
    ctx.beginPath();
    ctx.moveTo(ax + Math.cos(ang+Math.PI*0.5)*6, ay + Math.sin(ang+Math.PI*0.5)*6);
    ctx.lineTo(ax + Math.cos(ang-Math.PI*0.5)*6, ay + Math.sin(ang-Math.PI*0.5)*6);
    ctx.lineTo(player.x + Math.cos(ang)*(player.r+18), player.y + Math.sin(ang)*(player.r+18));
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fill();

    // small outline
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.stroke();
  }

  function drawBullets(){
    ctx.fillStyle = '#ffd966';
    for(const b of bullets){
      ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawEnemies(){
    for(const e of enemies){
      ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fillStyle = e.hp>30 ? '#00e6ff' : '#ffb86b'; ctx.fill();
      // hp bar above
      const w = 28; const hh = 4;
      const pct = Math.max(0, e.hp) / 100;
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(e.x - w/2, e.y - e.r - 12, w, hh);
      ctx.fillStyle = 'linear-gradient(90deg,#00e6ff,#00bfff)';
      ctx.fillStyle = '#00e6ff';
      ctx.fillRect(e.x - w/2, e.y - e.r - 12, w * pct, hh);
    }
  }

  function drawHUD(){
    // already DOM HUD updates handle bars
  }

  // collision helpers
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }
  function circleRectCollide(cx,cy,cr,rect){
    const rx = clamp(cx, rect.x, rect.x + rect.w);
    const ry = clamp(cy, rect.y, rect.y + rect.h);
    const dx = cx - rx, dy = cy - ry;
    return (dx*dx + dy*dy) < (cr*cr);
  }

  // movement with simple wall slide
  function tryMove(obj, vx, vy){
    let nx = obj.x + vx, ny = obj.y + vy;
    for(const w of walls){
      if(circleRectCollide(nx, ny, obj.r, w)){
        // try slide on X only
        if(!circleRectCollide(obj.x + vx, obj.y, obj.r, w)){
          nx = obj.x + vx; ny = obj.y;
        } else if(!circleRectCollide(obj.x, obj.y + vy, obj.r, w)){
          nx = obj.x; ny = obj.y + vy;
        } else {
          nx = obj.x; ny = obj.y;
        }
      }
    }
    // clamp to map
    obj.x = clamp(nx, obj.r + 6, W - obj.r - 6);
    obj.y = clamp(ny, obj.r + 6, H - obj.r - 6);
  }

  // shooting
  function playerShoot(){
    const wep = WEAPONS[selectedWeapon];
    const now = performance.now();
    if(now - player.lastShot < wep.fireRate) return;
    player.lastShot = now;
    const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    if(wep.pellets <= 1){
      bullets.push({ x: player.x + Math.cos(angle)*(player.r+8), y: player.y + Math.sin(angle)*(player.r+8), vx: Math.cos(angle)*wep.bulletSpeed, vy: Math.sin(angle)*wep.bulletSpeed, life:60, damage:wep.damage });
    } else {
      // shotgun spread
      const spread = wep.spread || 0.5;
      const p = wep.pellets;
      for(let i=0;i<p;i++){
        const a = angle + (Math.random()-0.5)*spread;
        bullets.push({ x: player.x + Math.cos(a)*(player.r+8), y: player.y + Math.sin(a)*(player.r+8), vx: Math.cos(a)*wep.bulletSpeed, vy: Math.sin(a)*wep.bulletSpeed, life:50, damage:wep.damage });
      }
    }
  }

  // melee
  function playerMelee(){
    if(!running) return;
    if(player.meleeCooldown && player.meleeCooldown>0) return;
    player.meleeCooldown = 36;
    // damage close enemies
    for(const e of enemies){
      if(dist(player.x,player.y,e.x,e.y) < player.r + e.r + 12){
        e.hp -= 48;
      }
    }
  }

  // game update loop
  let lastTime = performance.now();
  function update(now){
    const dt = (now - lastTime);
    lastTime = now;
    if(!running) return;

    // spawn logic for levels
    if(levelConfig.type === 'infinite'){
      if(now - lastSpawnTime > levelConfig.spawnRate){ spawnEnemy(); lastSpawnTime = now; }
    } else {
      // finite: spawn until totalSpawned reaches maxTotalSpawns
      if(totalSpawned < (levelConfig.maxTotalSpawns||30) && (now - lastSpawnTime > levelConfig.spawnRate)){
        spawnEnemy(); lastSpawnTime = now;
      }
    }

    // player input
    let dx = 0, dy = 0;
    if(keys['w']||keys['arrowup']) dy -= 1;
    if(keys['s']||keys['arrowdown']) dy += 1;
    if(keys['a']||keys['arrowleft']) dx -= 1;
    if(keys['d']||keys['arrowright']) dx += 1;
    if(dx || dy){
      const mag = Math.hypot(dx,dy); dx /= mag; dy /= mag;
      tryMove(player, dx * player.speed, dy * player.speed);
    }
    // shooting auto while mouse down
    if(mouse.down) playerShoot();

    // bullets movement + collisions
    for(let i = bullets.length-1; i>=0; i--){
      const b = bullets[i];
      b.x += b.vx; b.y += b.vy; b.life--;
      // hit walls
      let collided = false;
      for(const w of walls){ if(circleRectCollide(b.x, b.y, 3, w)){ collided = true; break; } }
      if(collided || b.life <= 0 || b.x < 0 || b.x > W || b.y < 0 || b.y > H){ bullets.splice(i,1); continue; }
      // hit enemies
      for(const e of enemies){
        if(dist(b.x, b.y, e.x, e.y) < e.r + 3){
          e.hp -= b.damage;
          bullets.splice(i,1);
          break;
        }
      }
    }

    // enemies update
    for(let i = enemies.length-1; i>=0; i--){
      const e = enemies[i];
      if(e.hp <= 0){ enemies.splice(i,1); score += 100; scoreText.textContent = score; continue; }
      const angle = Math.atan2(player.y - e.y, player.x - e.x);
      const spd = 0.9 + Math.random()*0.6;
      tryMove(e, Math.cos(angle) * spd, Math.sin(angle) * spd);
      // attack
      if(dist(e.x,e.y,player.x,player.y) < e.r + player.r + 6 && (e.attackCooldown || 0) <= 0){
        player.hp -= 14;
        e.attackCooldown = 40;
        if(player.hp < 0) player.hp = 0;
      }
      if(e.attackCooldown && e.attackCooldown>0) e.attackCooldown--;
    }

    // melee cooldown
    if(player.meleeCooldown && player.meleeCooldown>0) player.meleeCooldown--;

    // update HUD
    hpText.textContent = Math.max(0, player.hp);
    hpBar.style.width = Math.max(0, (player.hp/100)*100) + '%';

    // death check
    if(player.hp <= 0 && running){
      // game over
      running = false;
      menu.style.display = 'flex';
      menu.querySelector('h1').textContent = 'Game Over';
      menu.querySelector('.desc').textContent = 'Du døde — prøv igen. Shotgun unlock hvis du klarede Level 1 tidligere.';
      menu.querySelector('.start').textContent = 'Spil igen';
      // keep shotgun unlocked status
      // leave selected weapon state as is
      // no auto-unlock now
    }

    // level clear check for finite
    if(levelConfig.type === 'finite' && running){
      // if no enemies left and no more will spawn
      if(enemies.length === 0 && totalSpawned >= (levelConfig.maxTotalSpawns||30)){
        // level complete
        running = false;
        // unlock shotgun on level 1 completion
        if(levelChoice === '1'){
          shotgunUnlocked = true;
          wShotgun.classList.remove('locked');
          const lock = wShotgun.querySelector('.weapon-lock'); if(lock) lock.parentNode.removeChild(lock);
        }
        menu.style.display = 'flex';
        menu.querySelector('h1').textContent = 'Level Clear!';
        menu.querySelector('.desc').textContent = 'Du har klaret level 1. Shotgun er nu unlocked!';
        menu.querySelector('.start').textContent = 'Næste';
      }
    }
  }

  // render
  function render(){
    clear();
    drawWalls();
    drawEnemies();
    drawBullets();
    if(player) drawPlayer();
    // small overlay text for level name
    if(levelConfig){
      ctx.font = '14px monospace'; ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillText(levelConfig.name || '', 12, H - 12);
    }
  }

  function loop(now){
    update(now || performance.now());
    render();
    requestAnimationFrame(loop);
  }

  // initial UI setup
  highlightLevel();
  selectWeapon('pistol');

  // helper defaults
  let lastSpawnTime = performance.now();

  // start loop
  requestAnimationFrame(loop);

  // ensure we track spawn times
  setInterval(()=>{
    if(!running) return;
    const now = performance.now();
    if(levelConfig && levelConfig.spawnRate && (now - lastSpawnTime) > levelConfig.spawnRate){
      // for finite level only spawn until maxTotalSpawns
      if(levelConfig.type === 'infinite' || totalSpawned < (levelConfig.maxTotalSpawns||30)) spawnEnemy();
      lastSpawnTime = now;
    }
  }, 120);

  // expose small debug (optional)
  window._HOTLINE = {
    unlockShotgun: ()=>{ shotgunUnlocked = true; wShotgun.classList.remove('locked'); const l = wShotgun.querySelector('.weapon-lock'); if(l) l.remove(); },
  };
})();
</script>
</body>
</html>
