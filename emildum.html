<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FX Maker — Cyberpunk Neon</title>
<style>
  :root{
    --bg1: #0b0f1a;
    --bg2: #0f0b1f;
    --panel: rgba(255,255,255,0.04);
    --accent1: #ff2d95;
    --accent2: #6df0ff;
    --accent3: #7a3bff;
    --glass: rgba(255,255,255,0.06);
    --glass-strong: rgba(255,255,255,0.08);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:
    radial-gradient(1200px 700px at 10% 10%, rgba(122,59,255,0.06), transparent 10%),
    radial-gradient(1000px 600px at 90% 90%, rgba(109,240,255,0.04), transparent 20%),
    linear-gradient(180deg,var(--bg1),var(--bg2)); color:#e6eef8}
  .app {
    display:flex; gap:18px; height:100vh; padding:22px;
  }

  /* Sidebar */
  .sidebar {
    width:320px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px; padding:18px; border:1px solid rgba(255,255,255,0.04);
    box-shadow: 0 8px 30px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    backdrop-filter: blur(8px) saturate(1.1);
    overflow:auto;
  }
  .brand {text-align:center; margin-bottom:8px}
  .brand h1 {margin:0; font-size:20px; letter-spacing:1px; color:var(--accent2)}
  .upload {
    display:flex; gap:8px; align-items:center; margin:12px 0;
  }
  .filebtn {
    flex:1; padding:10px 12px; border-radius:10px; border:1px dashed rgba(255,255,255,0.06);
    background:linear-gradient(180deg, rgba(255,255,255,0.008), transparent);
    color:#dff7ff; cursor:pointer; font-weight:600; text-align:center;
  }
  .small{font-size:12px; color:rgba(230,238,248,0.75)}

  /* Buttons */
  .controls {display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:12px}
  .btn {
    padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.05);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.008));
    color:#fff; font-weight:700; cursor:pointer; transition:transform .12s ease, box-shadow .12s;
    box-shadow: 0 4px 18px rgba(122,59,255,0.04);
  }
  .btn:hover {transform:translateY(-3px); box-shadow:0 10px 30px rgba(122,59,255,0.08)}
  .btn.ghost {background:transparent; border:1px solid rgba(255,255,255,0.03); font-weight:600}
  .section {margin-top:18px}
  .section h3 {margin:4px 0 10px 0; font-size:13px; color:var(--accent3); text-transform:uppercase; letter-spacing:1px}

  /* sliders */
  .row {display:flex; gap:8px; align-items:center; margin-bottom:8px}
  .label {width:110px; font-size:13px; color:rgba(230,238,248,0.8)}
  input[type=range]{flex:1}

  /* Canvas area */
  .stage {
    flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center;
  }
  .panel {
    width:92%; max-width:1100px; height:78vh; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border-radius:14px; padding:18px; border:1px solid rgba(255,255,255,0.03);
    box-shadow: 0 20px 60px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    display:flex; gap:12px; align-items:center; justify-content:center; position:relative;
  }
  .canvas-wrap{
    width:78%; height:100%; display:flex; align-items:center; justify-content:center; position:relative;
  }
  canvas { background:#0b0b10; max-width:100%; max-height:100%; border-radius:8px; display:block;
    box-shadow: 0 18px 50px rgba(0,0,0,0.7), 0 0 24px rgba(122,59,255,0.06);
    transform-style: preserve-3d;
  }

  /* right-side mini-controls */
  .mini {
    width:280px; display:flex; flex-direction:column; gap:10px; height:100%;
  }
  .chip {padding:10px; border-radius:10px; background:var(--glass); border:1px solid rgba(255,255,255,0.02)}
  .preset {display:flex; gap:8px; flex-wrap:wrap}

  /* neon accent */
  .neon {
    display:inline-block; padding:6px 10px; border-radius:8px; background:linear-gradient(90deg,var(--accent1),var(--accent2));
    color:#08101a; font-weight:800; box-shadow: 0 8px 40px rgba(109,240,255,0.06), 0 0 18px rgba(255,45,149,0.06);
  }

  /* small helpers */
  .muted {color:rgba(230,238,248,0.6); font-size:13px}
  .flexcol{display:flex; flex-direction:column}
  .center{display:flex; align-items:center; justify-content:center}
  .kbd {padding:6px 8px; border-radius:6px; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.02); font-weight:700}

  /* CSS animations for some UI effects */
  @keyframes pop {
    0%{transform:scale(0.98);opacity:0}
    60%{transform:scale(1.02);opacity:1}
    100%{transform:scale(1)}
  }
  .panel {animation:pop .28s ease-out both}

  /* small responsive */
  @media(max-width:1100px){
    .sidebar {display:none}
    .canvas-wrap{width:100%}
    .panel {padding:12px}
  }

  /* shake animation for CSS-only glitches (fallback) */
  @keyframes css-shake {
    0%{transform:translate(0,0)}
    20%{transform:translate(-6px,3px)}
    40%{transform:translate(6px,-3px)}
    60%{transform:translate(-4px,2px)}
    80%{transform:translate(4px,-2px)}
    100%{transform:translate(0,0)}
  }
</style>
</head>
<body>
<div class="app">
  <!-- LEFT SIDEBAR -->
  <div class="sidebar">
    <div class="brand">
      <h1>FX MAKER <span class="neon">CYBERPUNK</span></h1>
      <div class="small">All-in-one image effects — spin, warp, glitch & neon</div>
    </div>

    <div class="upload">
      <label class="filebtn" title="Click to upload">
        Upload Image
        <input id="file" type="file" accept="image/*" style="display:none">
      </label>
    </div>
    <div class="small muted">Or drag & drop the image onto the canvas</div>

    <div class="section">
      <h3>Spin & Rotation</h3>
      <div class="controls">
        <button class="btn" id="spin-slow">Spin ⟳ (slow)</button>
        <button class="btn" id="spin-fast">Spin ⟳ (fast)</button>
        <button class="btn" id="spin-burst">Spin Burst</button>
        <button class="btn" id="spin-zoom">Spin + Zoom</button>
      </div>
      <div style="margin-top:8px" class="row">
        <div class="label small">Speed</div>
        <input id="speed" type="range" min="0.1" max="6" step="0.1" value="1">
      </div>
    </div>

    <div class="section">
      <h3>3D & Flip</h3>
      <div class="controls">
        <button class="btn" id="flip-x">Flip X</button>
        <button class="btn" id="flip-y">Flip Y</button>
        <button class="btn" id="flip-3d">3D Flip</button>
        <button class="btn" id="spin-until">Spin until stop</button>
      </div>
    </div>

    <div class="section">
      <h3>Glitch & VHS</h3>
      <div class="controls">
        <button class="btn" id="glitch">Glitch</button>
        <button class="btn" id="vhs">VHS</button>
        <button class="btn" id="rgb">RGB Split</button>
        <button class="btn" id="slice">Slice Glitch</button>
      </div>
      <div class="row" style="margin-top:8px">
        <div class="label small">Intensity</div>
        <input id="intensity" type="range" min="0" max="1" step="0.01" value="0.6">
      </div>
    </div>

    <div class="section">
      <h3>Warp & Distort</h3>
      <div class="controls">
        <button class="btn" id="wave">Wave</button>
        <button class="btn" id="ripple">Ripple</button>
        <button class="btn" id="pixel">Pixelate</button>
        <button class="btn" id="shock">Shockwave</button>
      </div>
    </div>

    <div class="section">
      <h3>Fun Motion</h3>
      <div class="controls">
        <button class="btn" id="bounce">Bounce</button>
        <button class="btn" id="wobble">Wobble</button>
        <button class="btn" id="jelly">Jelly</button>
        <button class="btn" id="quake">Earthquake</button>
      </div>
    </div>

    <div class="section">
      <h3>General</h3>
      <div class="controls">
        <button class="btn ghost" id="stopAll">Stop All</button>
        <button class="btn" id="bake">Bake Frame</button>
        <button class="btn ghost" id="reset">Reset Image</button>
        <button class="btn" id="download">Download</button>
      </div>
    </div>

    <div class="section small muted">
      Tip: click multiple effect buttons to combine them. Click "Bake" to rasterize the current animated state into the canvas.
    </div>
  </div>

  <!-- STAGE -->
  <div class="stage">
    <div class="panel">
      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="canvas"></canvas>
      </div>
      <div class="mini">
        <div class="chip center">
          <div style="font-weight:800;color:var(--accent2)">Live Controls</div>
          <div class="small muted">FPS: <span id="fps">--</span></div>
        </div>
        <div class="chip">
          <div style="font-weight:700; margin-bottom:6px">Current Effects</div>
          <div id="activeList" class="small muted">none</div>
        </div>
        <div class="chip">
          <div style="font-weight:700; margin-bottom:6px">Quick Presets</div>
          <div class="preset">
            <button class="btn" id="preset1">Neon Glitch</button>
            <button class="btn" id="preset2">VHS Retro</button>
            <button class="btn" id="preset3">Spin Warp</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* =============================
   CORE: canvas, image & manager
   ============================= */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const wrap = document.getElementById('canvasWrap');
let baseImg = new Image();
let originalImageData = null;

// sizing helper (fit to wrapper)
function fitCanvasToWrap() {
  const rect = wrap.getBoundingClientRect();
  const maxW = rect.width - 8;
  const maxH = rect.height - 8;
  let w = baseImg.width || 800, h = baseImg.height || 600;
  const ratio = w/h;
  if (w > maxW) { w = maxW; h = Math.round(w/ratio); }
  if (h > maxH) { h = maxH; w = Math.round(h*ratio); }
  canvas.width = w; canvas.height = h;
}
function drawBase() {
  if (!baseImg.src) {
    ctx.fillStyle = "#05060a";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    return;
  }
  fitCanvasToWrap();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);
  originalImageData = ctx.getImageData(0,0,canvas.width,canvas.height);
}

/* =============================
   Effects manager & states
   ============================= */
const effects = {
  spin: {running:false, angle:0, speed: 0.02},
  spinFast: {running:false, angle:0, speed: 0.12},
  spinUntil: {running:false, angle:0, speed:0.08},
  spinZoom: {running:false, angle:0, speed:0.06, zoom:1},
  flipX: false, flipY:false, flip3D:false,
  glitch: {running:false, t:0},
  rgb: {running:false, offset:6},
  vhs: {running:false, t:0},
  wave: {running:false, t:0},
  ripple: {running:false, pulses:[]},
  pixel: {running:false, size:10},
  shock: {running:false, t:0},
  wobble: {running:false, t:0},
  jelly: {running:false, t:0},
  bounce: {running:false, t:0},
  quake: {running:false, t:0},
  slice: {running:false, t:0},
};
let activeNames = new Set();
const activeEl = document.getElementById('activeList');

function setActive(name, on=true){
  if(on) activeNames.add(name);
  else activeNames.delete(name);
  activeEl.textContent = activeNames.size ? Array.from(activeNames).join(', ') : 'none';
}

/* =============================
   Upload + dragdrop
   ============================= */
const file = document.getElementById('file');
file.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  baseImg = new Image();
  baseImg.src = URL.createObjectURL(f);
  baseImg.onload = ()=>{ drawBase(); };
});
wrap.addEventListener('dragover', e=>{ e.preventDefault(); wrap.style.outline='2px dashed rgba(109,240,255,0.08)'; });
wrap.addEventListener('dragleave', e=>{ wrap.style.outline=''; });
wrap.addEventListener('drop', e=>{
  e.preventDefault(); wrap.style.outline='';
  const f = e.dataTransfer.files[0];
  if(!f) return;
  baseImg = new Image();
  baseImg.src = URL.createObjectURL(f);
  baseImg.onload = ()=>{ drawBase(); };
});

/* =============================
   Animation loop
   ============================= */
let raf = null;
let last = performance.now();
let fpsEl = document.getElementById('fps');
let frames = 0, fpsLast = performance.now();

function animate(now){
  const dt = (now - last) / 1000;
  last = now;
  frames++;
  if(now - fpsLast > 500){
    fpsEl.textContent = Math.round((frames / ((now - fpsLast)/1000)));
    fpsLast = now; frames = 0;
  }
  // update timers
  updateEffects(dt);
  renderFrame(now, dt);
  raf = requestAnimationFrame(animate);
}
function startLoop(){ if(!raf) { last = performance.now(); raf = requestAnimationFrame(animate); } }
function stopLoop(){ if(raf) cancelAnimationFrame(raf); raf = null; }

/* =============================
   Update effects (advance state)
   ============================= */
function updateEffects(dt){
  // general spin speeds controlled by the slider
  const speedSlider = document.getElementById('speed').value;
  if(effects.spin.running) effects.spin.angle += effects.spin.speed * dt * 60 * speedSlider;
  if(effects.spinFast.running) effects.spinFast.angle += effects.spinFast.speed * dt * 60 * speedSlider;
  if(effects.spinUntil.running) effects.spinUntil.angle += effects.spinUntil.speed * dt * 60 * speedSlider;
  if(effects.spinZoom.running) { effects.spinZoom.angle += effects.spinZoom.speed * dt * 60 * speedSlider; effects.spinZoom.zoom = 1 + 0.08*Math.sin(effects.spinZoom.angle*0.6); }
  if(effects.glitch.running) effects.glitch.t += dt * 2;
  if(effects.vhs.running) effects.vhs.t += dt * 1.6;
  if(effects.wave.running) effects.wave.t += dt * 2.2;
  if(effects.shock.running) effects.shock.t += dt * 3;
  if(effects.wobble.running) effects.wobble.t += dt * 3;
  if(effects.jelly.running) effects.jelly.t += dt * 4;
  if(effects.quake.running) effects.quake.t += dt * 2.8;
  if(effects.slice.running) effects.slice.t += dt * 2.6;
  // ripple pulses decay
  effects.ripple.pulses = effects.ripple.pulses.filter(p=> { p.t += dt*2; return p.t < 1; });
}

/* =============================
   Rendering (composed)
   ============================= */
function renderFrame(now, dt){
  // clear
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // base draw into offscreen
  const off = document.createElement('canvas');
  off.width = canvas.width; off.height = canvas.height;
  const oc = off.getContext('2d');
  oc.clearRect(0,0,off.width,off.height);
  if(baseImg && baseImg.complete && baseImg.naturalWidth){
    oc.drawImage(baseImg, 0, 0, off.width, off.height);
  } else {
    // placeholder
    oc.fillStyle = "#05060a"; oc.fillRect(0,0,off.width,off.height);
  }

  // apply pixelate first if active
  if(effects.pixel.running){
    const size = Math.max(2, effects.pixel.size);
    const small = document.createElement('canvas');
    small.width = Math.round(off.width/size);
    small.height = Math.round(off.height/size);
    const sc = small.getContext('2d');
    sc.imageSmoothingEnabled = false;
    sc.drawImage(off, 0, 0, small.width, small.height);
    oc.clearRect(0,0,off.width,off.height);
    oc.imageSmoothingEnabled = false;
    oc.drawImage(small, 0, 0, small.width, small.height, 0, 0, off.width, off.height);
  }

  // Make a working copy for distortions
  let working = document.createElement('canvas');
  working.width = off.width; working.height = off.height;
  const wc = working.getContext('2d');
  wc.drawImage(off, 0, 0);

  // GLITCH/SLICES: cut and shift horizontal stripes
  if(effects.slice.running || effects.glitch.running){
    const intensity = parseFloat(document.getElementById('intensity').value) || 0.6;
    const sliceCount = 6;
    for(let i=0;i<sliceCount;i++){
      const h = Math.round(off.height/sliceCount);
      const y = i*h;
      const sx = Math.round(10 * Math.sin(effects.slice.t*6 + i));
      const dx = sx * (effects.slice.running ? 1 : (Math.random()*0.6));
      const imgData = wc.getImageData(0,y,off.width,h);
      // draw shifted
      oc.putImageData(imgData, dx, y);
    }
  } else {
    oc.drawImage(working,0,0);
  }

  // RGB split / chromatic aberration
  if(effects.rgb.running){
    const offset = effects.rgb.offset;
    // draw R channel shifted
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.drawImage(working, -offset, 0, canvas.width+offset, canvas.height);
    ctx.globalCompositeOperation = 'lighter';
    // blue
    ctx.globalCompositeOperation = 'screen';
    ctx.drawImage(working, offset, 0, canvas.width+offset, canvas.height);
    ctx.restore();
  }

  // VHS: add scanlines and slight jitter
  if(effects.vhs.running){
    const jitter = 4*Math.sin(effects.vhs.t*12);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(jitter, 0);
    ctx.drawImage(oc.canvas, 0, 0);
    ctx.restore();
    // scanlines
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    for(let y=0;y<canvas.height;y+=3){
      ctx.fillRect(0,y,canvas.width,1);
    }
  } else if(!effects.rgb.running){
    // default: draw oc to main
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(oc.canvas, 0, 0);
  }

  // Wave / ripple distort (pixel displacement)
  if(effects.wave.running || effects.ripple.pulses.length){
    const imgd = ctx.getImageData(0,0,canvas.width,canvas.height);
    const out = ctx.createImageData(imgd.width,imgd.height);
    const w=imgd.width,h=imgd.height;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        let nx = x, ny = y;
        if(effects.wave.running){
          nx = Math.round(x + 8*Math.sin((y/10) + effects.wave.t*6));
          ny = Math.round(y + 6*Math.sin((x/18) + effects.wave.t*4));
        }
        // ripple pulses
        effects.ripple.pulses.forEach(p=>{
          const cx = w*0.5, cy = h*0.5;
          const dx = x-cx, dy = y-cy;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const r = p.t* Math.max(w,h);
          const amp = Math.max(0, 8*(1 - Math.abs(dist - r)/100));
          nx += amp * Math.cos(dist/10 + p.t*10);
          ny += amp * Math.sin(dist/10 + p.t*10);
        });

        nx = Math.max(0, Math.min(w-1, nx));
        ny = Math.max(0, Math.min(h-1, ny));
        const srcI = (ny*w + nx)*4;
        const dstI = (y*w + x)*4;
        out.data[dstI]   = imgd.data[srcI];
        out.data[dstI+1] = imgd.data[srcI+1];
        out.data[dstI+2] = imgd.data[srcI+2];
        out.data[dstI+3] = imgd.data[srcI+3];
      }
    }
    ctx.putImageData(out,0,0);
  }

  // Shockwave visual overlay
  if(effects.shock.running){
    const n = effects.shock.t % 1;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const grd = ctx.createRadialGradient(canvas.width/2,canvas.height/2, 0, canvas.width/2,canvas.height/2, canvas.width/1.8);
    grd.addColorStop(0, `rgba(255,45,149,${0.08*(1-n)})`);
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  // CSS-like transforms for spin/flip/zoom/jelly/etc: draw into temp and transform while painting
  let temp = document.createElement('canvas');
  temp.width = canvas.width; temp.height = canvas.height;
  let tc = temp.getContext('2d');
  tc.clearRect(0,0,temp.width,temp.height);
  tc.drawImage(canvas,0,0);

  // Now final composition with transforms
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);

  // compute cumulative rotation/scale
  let rot = 0;
  let scale = 1;
  if(effects.spin.running) rot += effects.spin.angle;
  if(effects.spinFast.running) rot += effects.spinFast.angle;
  if(effects.spinUntil.running) rot += effects.spinUntil.angle;
  if(effects.spinZoom.running) { rot += effects.spinZoom.angle; scale *= effects.spinZoom.zoom; }
  if(effects.jelly.running) { scale *= 1 + 0.06*Math.sin(effects.jelly.t*10); }
  if(effects.wobble.running) { rot += 0.06*Math.sin(effects.wobble.t*12); }

  ctx.rotate(rot);
  ctx.scale(scale, scale);

  // flips
  let flipScaleX = effects.flipX ? -1 : 1;
  let flipScaleY = effects.flipY ? -1 : 1;
  if(effects.flip3D){ // simulate 3D tilt by skew
    ctx.transform(1, 0.0, Math.sin((effects.spinZoom.angle||0)*0.2)*0.3, 1, 0, 0);
  }
  ctx.scale(flipScaleX, flipScaleY);

  // quake: jitter
  if(effects.quake.running){
    const jx = 8*Math.sin(effects.quake.t*60);
    const jy = 8*Math.cos(effects.quake.t*50);
    ctx.translate(jx, jy);
  }

  // Draw image
  ctx.drawImage(temp, -canvas.width/2, -canvas.height/2, canvas.width, canvas.height);
  ctx.restore();

  // final overlay effects: chroma split or extra glitch lines
  if(effects.glitch.running){
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const t = effects.glitch.t;
    const dx = 8 * Math.sin(t*20);
    ctx.drawImage(temp, dx, 0, canvas.width, canvas.height);
    ctx.drawImage(temp, -dx*0.6, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  // extra overlay: tiny scanline shimmer
  if(effects.vhs.running){
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#ffffff';
    for(let y=0;y<canvas.height;y+=4){
      ctx.fillRect(0,y,canvas.width,1);
    }
    ctx.restore();
  }

  // CSS-glow neon overlay when certain combos active
  if(effects.spin.running || effects.glitch.running){
    ctx.save();
    const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
    g.addColorStop(0, 'rgba(122,59,255,0.03)');
    g.addColorStop(1, 'rgba(109,240,255,0.03)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  // End
  ctx.restore();
}

/* =============================
   Interaction: wire UI to effects
   ============================= */

function toggleSpin(on=false){
  effects.spin.running = !effects.spin.running;
  setActive('spin', effects.spin.running);
  startLoop();
}
function toggleSpinFast(){
  effects.spinFast.running = !effects.spinFast.running;
  setActive('spinFast', effects.spinFast.running);
  startLoop();
}
function spinBurst(){
  // run a fast burst for a short time using a promise
  effects.spinFast.running = true; setActive('spinFast',true); startLoop();
  setTimeout(()=>{ effects.spinFast.running = false; setActive('spinFast',false); }, 700);
}
function toggleSpinZoom(){
  effects.spinZoom.running = !effects.spinZoom.running;
  setActive('spinZoom', effects.spinZoom.running);
  startLoop();
}
function toggleSpinUntil(){
  effects.spinUntil.running = !effects.spinUntil.running;
  setActive('spinUntil', effects.spinUntil.running);
  startLoop();
}
function flipX(){ effects.flipX = !effects.flipX; setActive('flipX', effects.flipX); renderFrame(); }
function flipY(){ effects.flipY = !effects.flipY; setActive('flipY', effects.flipY); renderFrame(); }
function flip3D(){ effects.flip3D = !effects.flip3D; setActive('flip3D', effects.flip3D); startLoop(); }

function toggleGlitch(){
  effects.glitch.running = !effects.glitch.running; setActive('glitch', effects.glitch.running); startLoop();
}
function toggleRGB(){ effects.rgb.running = !effects.rgb.running; setActive('rgb', effects.rgb.running); startLoop(); }
function toggleVHS(){ effects.vhs.running = !effects.vhs.running; setActive('vhs', effects.vhs.running); startLoop(); }
function startSlice(){ effects.slice.running = !effects.slice.running; setActive('slice', effects.slice.running); startLoop(); }

function toggleWave(){ effects.wave.running = !effects.wave.running; setActive('wave', effects.wave.running); startLoop(); }
function addRipple(){ effects.ripple.pulses.push({t:0}); effects.ripple.pulses = effects.ripple.pulses.slice(-6); setActive('ripple', effects.ripple.pulses.length>0); startLoop(); }
function togglePixel(){ effects.pixel.running = !effects.pixel.running; setActive('pixel', effects.pixel.running); renderFrame(); }
function shock(){ effects.shock.running = true; effects.shock.t = 0; setActive('shock', true); startLoop(); setTimeout(()=>{ effects.shock.running=false; setActive('shock',false); }, 800); }

function toggleBounce(){ effects.bounce.running = !effects.bounce.running; setActive('bounce', effects.bounce.running); startLoop(); }
function toggleWobble(){ effects.wobble.running = !effects.wobble.running; setActive('wobble', effects.wobble.running); startLoop(); }
function toggleJelly(){ effects.jelly.running = !effects.jelly.running; setActive('jelly', effects.jelly.running); startLoop(); }
function toggleQuake(){ effects.quake.running = !effects.quake.running; setActive('quake', effects.quake.running); startLoop(); }

function stopAll(){
  for(const k in effects) {
    if(typeof effects[k] === 'object') {
      effects[k].running = false;
      if(effects[k].t!==undefined) effects[k].t = 0;
    } else {
      effects[k] = false;
    }
  }
  activeNames.clear();
  setActive(); // refresh display
  renderFrame();
  stopLoop();
}

/* =============================
   bake, reset, download
   ============================= */
function bake(){
  // simply draw current frame then clear animation states
  stopAll();
  // save to baseImg (rasterize)
  const data = canvas.toDataURL('image/png');
  baseImg = new Image();
  baseImg.src = data;
  baseImg.onload = ()=>{ drawBase(); };
}
function resetImage(){
  if(originalImageData){
    canvas.width = originalImageData.width; canvas.height = originalImageData.height;
    ctx.putImageData(originalImageData, 0,0);
  } else {
    drawBase();
  }
}
function download(){
  const a = document.createElement('a');
  a.href = canvas.toDataURL('image/png');
  a.download = 'fx-export.png';
  a.click();
}

/* =============================
   wire DOM events
   ============================= */
document.getElementById('spin-slow').addEventListener('click', toggleSpin);
document.getElementById('spin-fast').addEventListener('click', toggleSpinFast);
document.getElementById('spin-burst').addEventListener('click', spinBurst);
document.getElementById('spin-zoom').addEventListener('click', toggleSpinZoom);
document.getElementById('spin-until').addEventListener('click', toggleSpinUntil);

document.getElementById('flip-x').addEventListener('click', flipX);
document.getElementById('flip-y').addEventListener('click', flipY);
document.getElementById('flip-3d').addEventListener('click', flip3D);

document.getElementById('glitch').addEventListener('click', toggleGlitch);
document.getElementById('rgb').addEventListener('click', toggleRGB);
document.getElementById('vhs').addEventListener('click', toggleVHS);
document.getElementById('slice').addEventListener('click', startSlice);

document.getElementById('wave').addEventListener('click', toggleWave);
document.getElementById('ripple').addEventListener('click', addRipple);
document.getElementById('pixel').addEventListener('click', ()=>{ effects.pixel.size = 12; togglePixel(); });
document.getElementById('shock').addEventListener('click', shock);

document.getElementById('bounce').addEventListener('click', toggleBounce);
document.getElementById('wobble').addEventListener('click', toggleWobble);
document.getElementById('jelly').addEventListener('click', toggleJelly);
document.getElementById('quake').addEventListener('click', toggleQuake);

document.getElementById('stopAll').addEventListener('click', stopAll);
document.getElementById('bake').addEventListener('click', bake);
document.getElementById('reset').addEventListener('click', ()=>{ location.reload(); });
document.getElementById('download').addEventListener('click', download);

document.getElementById('speed').addEventListener('input', (e)=>{
  const v = parseFloat(e.target.value);
  effects.spin.speed = 0.02 * v;
  effects.spinFast.speed = 0.12 * v;
  effects.spinUntil.speed = 0.08 * v;
  effects.spinZoom.speed = 0.06 * v;
});

document.getElementById('intensity').addEventListener('input', (e)=>{
  const v = parseFloat(e.target.value);
  effects.rgb.offset = Math.round(6 * v);
  effects.pixel.size = Math.round(20 * (1-v) + 2*(v));
});

/* presets */
document.getElementById('preset1').addEventListener('click', ()=>{
  stopAll();
  effects.spin.running = true; effects.glitch.running = true; effects.rgb.running = true; effects.vhs.running = true;
  setActive('spin',true); setActive('glitch',true); setActive('rgb',true); setActive('vhs',true);
  startLoop();
});
document.getElementById('preset2').addEventListener('click', ()=>{
  stopAll();
  effects.vhs.running = true; effects.slice.running = true; effects.pixel.running = true;
  setActive('vhs',true); setActive('slice', true); setActive('pixel', true);
  startLoop();
});
document.getElementById('preset3').addEventListener('click', ()=>{
  stopAll();
  effects.spinZoom.running = true; effects.wave.running = true; effects.ripple.pulses.push({t:0});
  setActive('spinZoom',true); setActive('wave',true); setActive('ripple',true);
  startLoop();
});

/* File input proxy: clicking label triggers file chooser */
document.querySelector('.filebtn').addEventListener('click', ()=>{ file.click(); });

/* drag to canvas to load image already handled above */

/* start empty */
drawBase();
startLoop();

</script>
</body>
</html>
