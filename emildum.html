<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Photoshop Browser Editor</title>
<style>
body { font-family:sans-serif; display:flex; flex-direction:column; align-items:center; margin:0; padding:0; }
canvas { border:2px solid black; margin-top:10px; cursor: crosshair; }
#toolbar { display:flex; flex-wrap:wrap; justify-content:center; margin:10px; }
#toolbar button, #toolbar input[type=color], #toolbar input[type=range] { margin:5px; padding:8px 15px; font-size:14px; cursor:pointer; }
</style>
</head>
<body>

<h1>Mini Photoshop Browser Editor</h1>
<input type="file" id="upload" accept="image/*"><br>

<div id="toolbar">
<!-- Vector -->
<button onclick="setDrawMode('circle')">Circle</button>
<button onclick="setDrawMode('rect')">Rect</button>
<button onclick="setDrawMode('line')">Line</button>
<button onclick="setDrawMode('free')">Freehand</button>
<button onclick="eraseVector()">Erase Vectors</button>
<input type="color" id="vectorColor" value="#ff0000">

<!-- Selection -->
<button onclick="setTool('lasso')">Lasso</button>
<button onclick="setTool('magic')">Magic Wand</button>

<!-- Painting -->
<button onclick="setTool('brush')">Brush</button>
<button onclick="setTool('eraser')">Eraser</button>
<button onclick="setTool('smudge')">Smudge</button>
<button onclick="setTool('clone')">Clone</button>

<!-- Effects -->
<button onclick="applyEffect('invert')">Invert</button>
<button onclick="applyEffect('grayscale')">Grayscale</button>
<button onclick="applyEffect('sepia')">Sepia</button>
<button onclick="applyEffect('pixelate')">Pixelate</button>
<button onclick="applyEffect('swirl')">Swirl</button>
<button onclick="applyEffect('bulge')">Bulge</button>
<button onclick="applyEffect('wave')">Wave</button>
<button onclick="applyEffect('mirror')">Mirror</button>
<button onclick="applyEffect('glitch')">Glitch</button>
<button onclick="applyEffect('huerotate')">Hue Rotate</button>
<button onclick="applyEffect('brightcontrast')">Brightness/Contrast</button>

<!-- Undo / Reset -->
<button onclick="undo()">Undo</button>
<button onclick="resetImage()">Reset</button>
</div>

<canvas id="canvas" width="500" height="500"></canvas>

<script>
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
let originalData=null;
let imgData=null;
let history=[];
let redoHistory=[];
let vectorShapes=[];
let drawMode=null;
let tool=null;
let drawing=false;
let startX,startY;
let color=document.getElementById('vectorColor').value;
let selectionMask=null;
let cloneSource=null;

// Upload image
document.getElementById('upload').addEventListener('change',e=>{
  const file=e.target.files[0];
  if(file){
    const reader=new FileReader();
    reader.onload=function(event){
      const img=new Image();
      img.onload=function(){
        const scale=Math.min(500/img.width,500/img.height);
        canvas.width=img.width*scale;
        canvas.height=img.height*scale;
        ctx.drawImage(img,0,0,canvas.width,canvas.height);
        imgData=ctx.getImageData(0,0,canvas.width,canvas.height);
        originalData=ctx.getImageData(0,0,canvas.width,canvas.height);
        saveHistory();
      }
      img.src=event.target.result;
    }
    reader.readAsDataURL(file);
  }
});

// History
function saveHistory(){
  if(imgData){
    history.push(ctx.getImageData(0,0,canvas.width,canvas.height));
    if(history.length>50) history.shift();
  }
}
function undo(){
  if(history.length>1){
    redoHistory.push(history.pop());
    imgData=history[history.length-1];
    redraw();
  }
}
function redo(){
  if(redoHistory.length>0){
    const data=redoHistory.pop();
    history.push(data);
    imgData=data;
    redraw();
  }
}

// Tools
function setDrawMode(mode){ drawMode=mode; tool=null; color=document.getElementById('vectorColor').value; }
function eraseVector(){ vectorShapes=[]; redraw(); }
function setTool(t){ tool=t; drawMode=null; color=document.getElementById('vectorColor').value; }

// Canvas mouse
canvas.addEventListener('mousedown',e=>{
  startX=e.offsetX; startY=e.offsetY; drawing=true;
  if(tool==='brush'||tool==='eraser'||tool==='smudge'||tool==='clone') saveHistory();
  if(tool==='lasso') selectionMask=[{x:startX,y:startY}];
  if(tool==='clone') cloneSource={x:startX,y:startY};
});
canvas.addEventListener('mousemove',e=>{
  if(!drawing) return;
  const x=e.offsetX; const y=e.offsetY;
  if(drawMode){ redraw(); ctx.strokeStyle=color; ctx.lineWidth=3; ctx.beginPath();
    if(drawMode==='circle'){ ctx.arc(startX,startY,Math.hypot(x-startX,y-startY),0,2*Math.PI); ctx.stroke(); }
    else if(drawMode==='rect'){ ctx.rect(startX,startY,x-startX,y-startY); ctx.stroke(); }
    else if(drawMode==='line'){ ctx.moveTo(startX,startY); ctx.lineTo(x,y); ctx.stroke(); }
    else if(drawMode==='free'){ ctx.moveTo(startX,startY); ctx.lineTo(x,y); ctx.stroke(); startX=x; startY=y; }
  }
  else if(tool==='brush'){ ctx.strokeStyle=color; ctx.lineWidth=5; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(startX,startY); ctx.lineTo(x,y); ctx.stroke(); startX=x; startY=y; }
  else if(tool==='eraser'){ ctx.strokeStyle='rgba(0,0,0,1)'; ctx.lineWidth=10; ctx.globalCompositeOperation='destination-out'; ctx.beginPath(); ctx.moveTo(startX,startY); ctx.lineTo(x,y); ctx.stroke(); ctx.globalCompositeOperation='source-over'; startX=x; startY=y; }
  else if(tool==='lasso'){ selectionMask.push({x,y}); redraw(); drawSelectionMask(); }
  else if(tool==='smudge'){ smudgePixels(startX,startY,x,y); startX=x; startY=y; }
  else if(tool==='clone'){ clonePixels(cloneSource.x,cloneSource.y,x,y); startX=x; startY=y; }
});
canvas.addEventListener('mouseup',e=>{ drawing=false; if(drawMode) vectorShapes.push({mode:drawMode,color,x:startX,y:startY,x2:e.offsetX,y2:e.offsetY}); if(tool==='lasso') drawSelectionMask(); });

// Redraw image + vectors
function redraw(){
  if(imgData) ctx.putImageData(imgData,0,0);
  for(const shape of vectorShapes){
    ctx.strokeStyle=shape.color; ctx.lineWidth=3; ctx.beginPath();
    if(shape.mode==='circle'){ const r=Math.hypot(shape.x2-shape.x,shape.y2-shape.y); ctx.arc(shape.x,shape.y,r,0,2*Math.PI); ctx.stroke(); }
    else if(shape.mode==='rect'){ ctx.rect(shape.x,shape.y,shape.x2-shape.x,shape.y2-shape.y); ctx.stroke(); }
    else if(shape.mode==='line'){ ctx.moveTo(shape.x,shape.y); ctx.lineTo(shape.x2,shape.y2); ctx.stroke(); }
    else if(shape.mode==='free'){ ctx.moveTo(shape.x,shape.y); ctx.lineTo(shape.x2,shape.y2); ctx.stroke(); }
  }
}

// Selection mask
function drawSelectionMask(){
  if(!selectionMask) return;
  ctx.strokeStyle='rgba(0,0,255,0.8)'; ctx.fillStyle='rgba(0,0,255,0.2)'; ctx.lineWidth=2; ctx.beginPath();
  ctx.moveTo(selectionMask[0].x,selectionMask[0].y);
  for(let i=1;i<selectionMask.length;i++) ctx.lineTo(selectionMask[i].x,selectionMask[i].y);
  ctx.closePath(); ctx.fill(); ctx.stroke();
}

// Simple smudge
function smudgePixels(x1,y1,x2,y2){
  const w=1; const h=1; const src=ctx.getImageData(x1-w/2,y1-h/2,w,h); ctx.putImageData(src,x2-w/2,y2-h/2);
}

// Simple clone
function clonePixels(sx,sy,dx,dy){
  const w=5; const h=5; const src=ctx.getImageData(sx,sy,w,h); ctx.putImageData(src,dx,dy);
}

// Effects (simplified example: invert)
function applyEffect(effect){
  if(!imgData) return;
  saveHistory();
  const data=ctx.getImageData(0,0,canvas.width,canvas.height);
  if(effect==='invert'){ for(let i=0;i<data.data.length;i+=4){ data.data[i]=255-data.data[i]; data.data[i+1]=255-data.data[i+1]; data.data[i+2]=255-data.data[i+2]; } }
  ctx.putImageData(data,0,0); imgData=data; redraw();
}

// Reset
function resetImage(){ if(originalData) imgData=new ImageData(new Uint8ClampedArray(originalData.data),originalData.width,originalData.height); vectorShapes=[]; selectionMask=null; redraw(); }
</script>
</body>
</html>
